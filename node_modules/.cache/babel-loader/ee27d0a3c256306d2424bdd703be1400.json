{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = autoBind;\nvar wontBind = ['constructor', 'render', 'componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount'];\nvar toBind = [];\n\nfunction autoBind(context) {\n  if (context === undefined) {\n    console.error('Autobind error: No context provided.');\n    return;\n  }\n\n  var objPrototype = Object.getPrototypeOf(context);\n\n  if (arguments.length > 1) {\n    // If a list of methods to bind is provided, use it.\n    toBind = Array.prototype.slice.call(arguments, 1);\n  } else {\n    // If no list of methods to bind is provided, bind all available methods in class.\n    toBind = Object.getOwnPropertyNames(objPrototype);\n  }\n\n  toBind.forEach(function (method) {\n    var descriptor = Object.getOwnPropertyDescriptor(objPrototype, method);\n\n    if (descriptor === undefined) {\n      console.warn('Autobind: \"' + method + '\" method not found in class.');\n      return;\n    } // Return if it's special case function or if not a function at all\n\n\n    if (wontBind.indexOf(method) !== -1 || typeof descriptor.value !== 'function') {\n      return;\n    }\n\n    Object.defineProperty(objPrototype, method, boundMethod(objPrototype, method, descriptor));\n  });\n}\n/**\n* From autobind-decorator (https://github.com/andreypopp/autobind-decorator/tree/master)\n* Return a descriptor removing the value and returning a getter\n* The getter will return a .bind version of the function\n* and memoize the result against a symbol on the instance\n*/\n\n\nfunction boundMethod(objPrototype, method, descriptor) {\n  var fn = descriptor.value;\n  return {\n    configurable: true,\n    get: function get() {\n      if (this === objPrototype || this.hasOwnProperty(method)) {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      Object.defineProperty(this, method, {\n        value: boundFn,\n        configurable: true,\n        writable: true\n      });\n      return boundFn;\n    }\n  };\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["E:/ISDL/S2E/D-PENS/markdowntest/markdowntest/node_modules/react-autobind/lib/autoBind.js"],"names":["Object","defineProperty","exports","value","autoBind","wontBind","toBind","context","undefined","console","error","objPrototype","getPrototypeOf","arguments","length","Array","prototype","slice","call","getOwnPropertyNames","forEach","method","descriptor","getOwnPropertyDescriptor","warn","indexOf","boundMethod","fn","configurable","get","hasOwnProperty","boundFn","bind","writable","module"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,QAArB;AACA,IAAIC,QAAQ,GAAG,CAAC,aAAD,EAAgB,QAAhB,EAA0B,oBAA1B,EAAgD,mBAAhD,EAAqE,2BAArE,EAAkG,uBAAlG,EAA2H,qBAA3H,EAAkJ,oBAAlJ,EAAwK,sBAAxK,CAAf;AAEA,IAAIC,MAAM,GAAG,EAAb;;AAEA,SAASF,QAAT,CAAkBG,OAAlB,EAA2B;AACzB,MAAIA,OAAO,KAAKC,SAAhB,EAA2B;AACzBC,IAAAA,OAAO,CAACC,KAAR,CAAc,sCAAd;AACA;AACD;;AAED,MAAIC,YAAY,GAAGX,MAAM,CAACY,cAAP,CAAsBL,OAAtB,CAAnB;;AAEA,MAAIM,SAAS,CAACC,MAAV,GAAmB,CAAvB,EAA0B;AACxB;AACAR,IAAAA,MAAM,GAAGS,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BL,SAA3B,EAAsC,CAAtC,CAAT;AACD,GAHD,MAGO;AACL;AACAP,IAAAA,MAAM,GAAGN,MAAM,CAACmB,mBAAP,CAA2BR,YAA3B,CAAT;AACD;;AAEDL,EAAAA,MAAM,CAACc,OAAP,CAAe,UAAUC,MAAV,EAAkB;AAC/B,QAAIC,UAAU,GAAGtB,MAAM,CAACuB,wBAAP,CAAgCZ,YAAhC,EAA8CU,MAA9C,CAAjB;;AAEA,QAAIC,UAAU,KAAKd,SAAnB,EAA8B;AAC5BC,MAAAA,OAAO,CAACe,IAAR,CAAa,gBAAgBH,MAAhB,GAAyB,8BAAtC;AACA;AACD,KAN8B,CAQ/B;;;AACA,QAAIhB,QAAQ,CAACoB,OAAT,CAAiBJ,MAAjB,MAA6B,CAAC,CAA9B,IAAmC,OAAOC,UAAU,CAACnB,KAAlB,KAA4B,UAAnE,EAA+E;AAC7E;AACD;;AAEDH,IAAAA,MAAM,CAACC,cAAP,CAAsBU,YAAtB,EAAoCU,MAApC,EAA4CK,WAAW,CAACf,YAAD,EAAeU,MAAf,EAAuBC,UAAvB,CAAvD;AACD,GAdD;AAeD;AAED;;;;;;;;AAMA,SAASI,WAAT,CAAqBf,YAArB,EAAmCU,MAAnC,EAA2CC,UAA3C,EAAuD;AACrD,MAAIK,EAAE,GAAGL,UAAU,CAACnB,KAApB;AAEA,SAAO;AACLyB,IAAAA,YAAY,EAAE,IADT;AAELC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,UAAI,SAASlB,YAAT,IAAyB,KAAKmB,cAAL,CAAoBT,MAApB,CAA7B,EAA0D;AACxD,eAAOM,EAAP;AACD;;AAED,UAAII,OAAO,GAAGJ,EAAE,CAACK,IAAH,CAAQ,IAAR,CAAd;AACAhC,MAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4BoB,MAA5B,EAAoC;AAClClB,QAAAA,KAAK,EAAE4B,OAD2B;AAElCH,QAAAA,YAAY,EAAE,IAFoB;AAGlCK,QAAAA,QAAQ,EAAE;AAHwB,OAApC;AAKA,aAAOF,OAAP;AACD;AAdI,GAAP;AAgBD;;AACDG,MAAM,CAAChC,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = autoBind;\nvar wontBind = ['constructor', 'render', 'componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount'];\n\nvar toBind = [];\n\nfunction autoBind(context) {\n  if (context === undefined) {\n    console.error('Autobind error: No context provided.');\n    return;\n  }\n\n  var objPrototype = Object.getPrototypeOf(context);\n\n  if (arguments.length > 1) {\n    // If a list of methods to bind is provided, use it.\n    toBind = Array.prototype.slice.call(arguments, 1);\n  } else {\n    // If no list of methods to bind is provided, bind all available methods in class.\n    toBind = Object.getOwnPropertyNames(objPrototype);\n  }\n\n  toBind.forEach(function (method) {\n    var descriptor = Object.getOwnPropertyDescriptor(objPrototype, method);\n\n    if (descriptor === undefined) {\n      console.warn('Autobind: \"' + method + '\" method not found in class.');\n      return;\n    }\n\n    // Return if it's special case function or if not a function at all\n    if (wontBind.indexOf(method) !== -1 || typeof descriptor.value !== 'function') {\n      return;\n    }\n\n    Object.defineProperty(objPrototype, method, boundMethod(objPrototype, method, descriptor));\n  });\n}\n\n/**\n* From autobind-decorator (https://github.com/andreypopp/autobind-decorator/tree/master)\n* Return a descriptor removing the value and returning a getter\n* The getter will return a .bind version of the function\n* and memoize the result against a symbol on the instance\n*/\nfunction boundMethod(objPrototype, method, descriptor) {\n  var fn = descriptor.value;\n\n  return {\n    configurable: true,\n    get: function get() {\n      if (this === objPrototype || this.hasOwnProperty(method)) {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      Object.defineProperty(this, method, {\n        value: boundFn,\n        configurable: true,\n        writable: true\n      });\n      return boundFn;\n    }\n  };\n}\nmodule.exports = exports['default'];\n"]},"metadata":{},"sourceType":"script"}